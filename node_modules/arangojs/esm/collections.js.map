{"version":3,"file":"collections.js","sourceRoot":"","sources":["../../src/collections.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * ```ts\r\n * import type {\r\n *   DocumentCollection,\r\n *   EdgeCollection,\r\n * } from \"arangojs/collections\";\r\n * ```\r\n *\r\n * The \"collections\" module provides collection related types and interfaces\r\n * for TypeScript.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport * as aql from \"./aql.js\";\r\nimport * as connection from \"./connection.js\";\r\nimport * as databases from \"./databases.js\";\r\nimport * as documents from \"./documents.js\";\r\nimport * as errors from \"./errors.js\";\r\nimport * as indexes from \"./indexes.js\";\r\nimport { COLLECTION_NOT_FOUND, DOCUMENT_NOT_FOUND } from \"./lib/codes.js\";\r\n\r\n//#region ArangoCollection interface\r\n/**\r\n * Indicates whether the given value represents an {@link ArangoCollection}.\r\n *\r\n * @param collection - A value that might be a collection.\r\n */\r\nexport function isArangoCollection(\r\n  collection: any\r\n): collection is ArangoCollection {\r\n  return Boolean(collection && collection.isArangoCollection);\r\n}\r\n\r\n/**\r\n * Coerces the given collection name or {@link ArangoCollection} object to\r\n * a string representing the collection name.\r\n *\r\n * @param collection - Collection name or {@link ArangoCollection} object.\r\n */\r\nexport function collectionToString(\r\n  collection: string | ArangoCollection\r\n): string {\r\n  if (isArangoCollection(collection)) {\r\n    return String(collection.name);\r\n  } else return String(collection);\r\n}\r\n\r\n/**\r\n * A marker interface identifying objects that can be used in AQL template\r\n * strings to create references to ArangoDB collections.\r\n *\r\n * See {@link aql.aql}.\r\n */\r\nexport interface ArangoCollection {\r\n  /**\r\n   * @internal\r\n   *\r\n   * Indicates that this object represents an ArangoDB collection.\r\n   */\r\n  readonly isArangoCollection: true;\r\n  /**\r\n   * Name of the collection.\r\n   */\r\n  readonly name: string;\r\n}\r\n//#endregion\r\n\r\n//#region Shared types\r\n/**\r\n * Integer values indicating the collection type.\r\n */\r\nexport enum CollectionType {\r\n  DOCUMENT_COLLECTION = 2,\r\n  EDGE_COLLECTION = 3,\r\n}\r\n\r\n/**\r\n * Integer values indicating the collection loading status.\r\n */\r\nexport enum CollectionStatus {\r\n  NEWBORN = 1,\r\n  UNLOADED = 2,\r\n  LOADED = 3,\r\n  UNLOADING = 4,\r\n  DELETED = 5,\r\n  LOADING = 6,\r\n}\r\n\r\n/**\r\n * Type of key generator.\r\n */\r\nexport type KeyGenerator = \"traditional\" | \"autoincrement\" | \"uuid\" | \"padded\";\r\n\r\n/**\r\n * Strategy for sharding a collection.\r\n */\r\nexport type ShardingStrategy =\r\n  | \"hash\"\r\n  | \"enterprise-hash-smart-edge\"\r\n  | \"enterprise-hash-smart-vertex\"\r\n  | \"community-compat\"\r\n  | \"enterprise-compat\"\r\n  | \"enterprise-smart-edge-compat\";\r\n\r\n/**\r\n * When a validation should be applied.\r\n *\r\n * * `\"none\"`: No validation.\r\n * * `\"new\"`: Newly inserted documents are validated.\r\n * * `\"moderate\"`: New and modified documents are validated unless the modified\r\n *   document was already invalid.\r\n * * `\"strict\"`: New and modified documents are always validated.\r\n */\r\nexport type ValidationLevel = \"none\" | \"new\" | \"moderate\" | \"strict\";\r\n\r\n/**\r\n * Write operation that can result in a computed value being computed.\r\n */\r\nexport type WriteOperation = \"insert\" | \"update\" | \"replace\";\r\n//#endregion\r\n\r\n//#region Collection operation options\r\n/**\r\n * Options for creating a collection.\r\n *\r\n * See {@link databases.Database#createCollection}, {@link databases.Database#createEdgeCollection}\r\n * and {@link DocumentCollection#create} or {@link EdgeCollection#create}.\r\n */\r\nexport type CreateCollectionOptions = CollectionPropertiesOptions & {\r\n  /**\r\n   * @internal\r\n   *\r\n   * Whether the collection should be created as a system collection.\r\n   *\r\n   * Default: `false`\r\n   */\r\n  isSystem?: boolean;\r\n  /**\r\n   * An object defining the collection's key generation.\r\n   */\r\n  keyOptions?: CollectionKeyOptions;\r\n  /**\r\n   * (Cluster only.) Unless set to `false`, the server will wait for all\r\n   * replicas to create the collection before returning.\r\n   *\r\n   * Default: `true`\r\n   */\r\n  waitForSyncReplication?: boolean;\r\n  /**\r\n   * (Cluster only.) Unless set to `false`, the server will check whether\r\n   * enough replicas are available at creation time and bail out otherwise.\r\n   *\r\n   * Default: `true`\r\n   */\r\n  enforceReplicationFactor?: boolean;\r\n  /**\r\n   * (Cluster only.) Number of shards to distribute the collection across.\r\n   *\r\n   * Default: `1`\r\n   */\r\n  numberOfShards?: number;\r\n  /**\r\n   * (Cluster only.) Document attributes to use to determine the target shard\r\n   * for each document.\r\n   *\r\n   * Default: `[\"_key\"]`\r\n   */\r\n  shardKeys?: string[];\r\n  /**\r\n   * (Cluster only.) Sharding strategy to use.\r\n   */\r\n  shardingStrategy?: ShardingStrategy;\r\n  /**\r\n   * (Enterprise Edition cluster only.) If set to a collection name, sharding\r\n   * of the new collection will follow the rules for that collection. As long\r\n   * as the new collection exists, the indicated collection can not be dropped.\r\n   */\r\n  distributeShardsLike?: string;\r\n  /**\r\n   * (Enterprise Edition cluster only.) Attribute containing the shard key\r\n   * value of the referred-to smart join collection.\r\n   */\r\n  smartJoinAttribute?: string;\r\n  /**\r\n   * (Enterprise Edition cluster only.) Attribute used for sharding.\r\n   */\r\n  smartGraphAttribute?: string;\r\n};\r\n\r\n/**\r\n * An object defining the collection's key generation.\r\n */\r\nexport type CollectionKeyOptions = {\r\n  /**\r\n   * Type of key generator to use.\r\n   */\r\n  type?: KeyGenerator;\r\n  /**\r\n   * Unless set to `false`, documents can be created with a user-specified\r\n   * `_key` attribute.\r\n   *\r\n   * Default: `true`\r\n   */\r\n  allowUserKeys?: boolean;\r\n  /**\r\n   * (Autoincrement only.) How many steps to increment the key each time.\r\n   */\r\n  increment?: number;\r\n  /**\r\n   * (Autoincrement only.) Initial offset for the key.\r\n   */\r\n  offset?: number;\r\n};\r\n\r\n/**\r\n * Options for setting a collection's properties.\r\n *\r\n * See {@link DocumentCollection#properties} and {@link EdgeCollection#properties}.\r\n */\r\nexport type CollectionPropertiesOptions = {\r\n  /**\r\n   * If set to `true`, data will be synchronized to disk before returning from\r\n   * a document create, update, replace or removal operation.\r\n   *\r\n   * Default: `false`\r\n   */\r\n  waitForSync?: boolean;\r\n  /**\r\n   * (Cluster only.) How many copies of each document should be kept in the\r\n   * cluster.\r\n   *\r\n   * Default: `1`\r\n   */\r\n  replicationFactor?: number | \"satellite\";\r\n  /**\r\n   * (Cluster only.) Write concern for this collection.\r\n   */\r\n  writeConcern?: number;\r\n  /**\r\n   * Options for validating documents in this collection.\r\n   */\r\n  schema?: SchemaOptions;\r\n  /**\r\n   * Computed values to apply to documents in this collection.\r\n   */\r\n  computedValues?: ComputedValueOptions[];\r\n  /**\r\n   * Whether the in-memory hash cache is enabled for this collection.\r\n   *\r\n   * Default: `false`\r\n   */\r\n  cacheEnabled?: boolean;\r\n};\r\n\r\n/**\r\n * Options for validating collection documents.\r\n */\r\nexport type SchemaOptions = {\r\n  /**\r\n   * JSON Schema description of the validation schema for documents.\r\n   */\r\n  rule: any;\r\n  /**\r\n   * When validation should be applied.\r\n   *\r\n   * Default: `\"strict\"`\r\n   */\r\n  level?: ValidationLevel;\r\n  /**\r\n   * Message to be used if validation fails.\r\n   */\r\n  message?: string;\r\n};\r\n\r\n/**\r\n * Options for creating a computed value.\r\n */\r\nexport type ComputedValueOptions = {\r\n  /**\r\n   * Name of the target attribute of the computed value.\r\n   */\r\n  name: string;\r\n  /**\r\n   * AQL `RETURN` expression that computes the value.\r\n   *\r\n   * Note that when passing an AQL query object, the `bindVars` will be ignored.\r\n   */\r\n  expression: string | aql.AqlLiteral | aql.AqlQuery;\r\n  /**\r\n   * If set to `false`, the computed value will not be applied if the\r\n   * expression evaluates to `null`.\r\n   *\r\n   * Default: `true`\r\n   */\r\n  overwrite?: boolean;\r\n  /**\r\n   * Which operations should result in the value being computed.\r\n   *\r\n   * Default: `[\"insert\", \"update\", \"replace\"]`\r\n   */\r\n  computeOn?: WriteOperation[];\r\n  /**\r\n   * If set to `false`, the field will be unset if the expression evaluates to\r\n   * `null`. Otherwise the field will be set to the value `null`. Has no effect\r\n   * if `overwrite` is set to `false`.\r\n   *\r\n   * Default: `true`\r\n   */\r\n  keepNull?: boolean;\r\n  /**\r\n   * Whether the write operation should fail if the expression produces a\r\n   * warning.\r\n   *\r\n   * Default: `false`\r\n   */\r\n  failOnWarning?: boolean;\r\n};\r\n\r\n/**\r\n * Options for retrieving a collection checksum.\r\n */\r\nexport type CollectionChecksumOptions = {\r\n  /**\r\n   * If set to `true`, revision IDs will be included in the calculation\r\n   * of the checksum.\r\n   *\r\n   * Default: `false`\r\n   */\r\n  withRevisions?: boolean;\r\n  /**\r\n   * If set to `true`, document data will be included in the calculation\r\n   * of the checksum.\r\n   *\r\n   * Default: `false`\r\n   */\r\n  withData?: boolean;\r\n};\r\n\r\n/**\r\n * Options for truncating collections.\r\n */\r\nexport type TruncateCollectionOptions = {\r\n  /**\r\n   * Whether the collection should be compacted after truncation.\r\n   */\r\n  compact?: boolean;\r\n  /**\r\n   * Whether data should be synchronized to disk before returning from this\r\n   * operation.\r\n   */\r\n  waitForSync?: boolean;\r\n};\r\n\r\n/**\r\n * Options for dropping collections.\r\n */\r\nexport type DropCollectionOptions = {\r\n  /**\r\n   * Whether the collection is a system collection. If the collection is a\r\n   * system collection, this option must be set to `true` or ArangoDB will\r\n   * refuse to drop the collection.\r\n   *\r\n   * Default: `false`\r\n   */\r\n  isSystem?: boolean;\r\n};\r\n//#endregion\r\n\r\n//#region CollectionDescription\r\n/**\r\n * General information about a collection.\r\n */\r\nexport type CollectionDescription = {\r\n  /**\r\n   * Collection name.\r\n   */\r\n  name: string;\r\n  /**\r\n   * A globally unique identifier for this collection.\r\n   */\r\n  globallyUniqueId: string;\r\n  /**\r\n   * An integer indicating the collection loading status.\r\n   */\r\n  status: CollectionStatus;\r\n  /**\r\n   * An integer indicating the collection type.\r\n   */\r\n  type: CollectionType;\r\n  /**\r\n   * @internal\r\n   *\r\n   * Whether the collection is a system collection.\r\n   */\r\n  isSystem: boolean;\r\n};\r\n//#endregion\r\n\r\n//#region CollectionProperties\r\n/**\r\n * An object defining the properties of a collection.\r\n */\r\nexport type CollectionProperties = {\r\n  /**\r\n   * A human-readable representation of the collection loading status.\r\n   */\r\n  statusString: string;\r\n  /**\r\n   * Whether data should be synchronized to disk before returning from\r\n   * a document create, update, replace or removal operation.\r\n   */\r\n  waitForSync: boolean;\r\n  /**\r\n   * An object defining the collection's key generation.\r\n   */\r\n  keyOptions: CollectionKeyProperties;\r\n  /**\r\n   * Properties for validating documents in the collection.\r\n   */\r\n  schema: SchemaProperties | null;\r\n  /**\r\n   * (Cluster only.) Write concern for this collection.\r\n   */\r\n  writeConcern: number;\r\n  /**\r\n   * (Cluster only.) Number of shards of this collection.\r\n   */\r\n  numberOfShards?: number;\r\n  /**\r\n   * (Cluster only.) Keys of this collection that will be used for\r\n   * sharding.\r\n   */\r\n  shardKeys?: string[];\r\n  /**\r\n   * (Cluster only.) Replication factor of the collection.\r\n   */\r\n  replicationFactor?: number | \"satellite\";\r\n  /**\r\n   * (Cluster only.) Sharding strategy of the collection.\r\n   */\r\n  shardingStrategy?: ShardingStrategy;\r\n  /**\r\n   * (Enterprise Edition cluster only.) If set to a collection name, sharding\r\n   * of the new collection will follow the rules for that collection. As long\r\n   * as the new collection exists, the indicated collection can not be dropped.\r\n   */\r\n  distributeShardsLike?: string;\r\n  /**\r\n   * (Enterprise Edition cluster only.) Attribute containing the shard key\r\n   * value of the referred-to smart join collection.\r\n   */\r\n  smartJoinAttribute?: string;\r\n  /**\r\n   * (Enterprise Edition cluster only.) Attribute used for sharding.\r\n   */\r\n  smartGraphAttribute?: string;\r\n  /**\r\n   * Computed values applied to documents in this collection.\r\n   */\r\n  computedValues: ComputedValueProperties[];\r\n  /**\r\n   * Whether the in-memory hash cache is enabled for this collection.\r\n   */\r\n  cacheEnabled: boolean;\r\n  /**\r\n   * Whether the newer revision-based replication protocol is enabled for\r\n   * this collection.\r\n   */\r\n  syncByRevision: boolean;\r\n  /**\r\n   * (Enterprise Edition only.) Whether the collection is used in a SmartGraph or EnterpriseGraph.\r\n   */\r\n  isSmart?: boolean;\r\n  /**\r\n   * (Enterprise Edition only.) Whether the SmartGraph this collection belongs to is disjoint.\r\n   */\r\n  isDisjoint?: string;\r\n};\r\n\r\n/**\r\n * An object defining the collection's key generation.\r\n */\r\nexport type CollectionKeyProperties = {\r\n  /**\r\n   * Type of key generator to use.\r\n   */\r\n  type: KeyGenerator;\r\n  /**\r\n   * Whether documents can be created with a user-specified `_key` attribute.\r\n   */\r\n  allowUserKeys: boolean;\r\n  /**\r\n   * (Autoincrement only.) How many steps to increment the key each time.\r\n   */\r\n  increment?: number;\r\n  /**\r\n   * (Autoincrement only.) Initial offset for the key.\r\n   */\r\n  offset?: number;\r\n  /**\r\n   * Most recent key that has been generated.\r\n   */\r\n  lastValue: number;\r\n};\r\n\r\n/**\r\n * Properties for validating documents in a collection.\r\n */\r\nexport type SchemaProperties = {\r\n  /**\r\n   * Type of document validation.\r\n   */\r\n  type: \"json\";\r\n  /**\r\n   * JSON Schema description of the validation schema for documents.\r\n   */\r\n  rule: any;\r\n  /**\r\n   * When validation should be applied.\r\n   */\r\n  level: ValidationLevel;\r\n  /**\r\n   * Message to be used if validation fails.\r\n   */\r\n  message: string;\r\n};\r\n\r\n/**\r\n * Properties defining a computed value.\r\n */\r\nexport type ComputedValueProperties = {\r\n  /**\r\n   * Name of the target attribute of the computed value.\r\n   */\r\n  name: string;\r\n  /**\r\n   * AQL `RETURN` expression that computes the value.\r\n   */\r\n  expression: string;\r\n  /**\r\n   * If set to `false`, the computed value will not be applied if the\r\n   * expression evaluates to `null`.\r\n   */\r\n  overwrite: boolean;\r\n  /**\r\n   * Which operations should result in the value being computed.\r\n   */\r\n  computeOn: WriteOperation[];\r\n  /**\r\n   * If set to `false`, the field will be unset if the expression evaluates to\r\n   * `null`. Otherwise the field will be set to the value `null`. Has no effect\r\n   * if `overwrite` is set to `false`.\r\n   */\r\n  keepNull: boolean;\r\n  /**\r\n   * Whether the write operation should fail if the expression produces a\r\n   * warning.\r\n   */\r\n  failOnWarning: boolean;\r\n};\r\n//#endregion\r\n\r\n//#region DocumentCollection interface\r\n/**\r\n * Represents an document collection in a {@link databases.Database}.\r\n *\r\n * See {@link EdgeCollection} for a variant of this interface more suited for\r\n * edge collections.\r\n *\r\n * When using TypeScript, collections can be cast to a specific document data\r\n * type to increase type safety.\r\n *\r\n * @param EntryResultType - Type to represent document contents returned by the\r\n * server (including computed properties).\r\n * @param EntryInputType - Type to represent document contents passed when\r\n * inserting or replacing documents (without computed properties).\r\n *\r\n * @example\r\n * ```ts\r\n * interface Person {\r\n *   name: string;\r\n * }\r\n * const db = new Database();\r\n * const documents = db.collection(\"persons\") as DocumentCollection<Person>;\r\n * ```\r\n */\r\nexport interface DocumentCollection<\r\n  EntryResultType extends Record<string, any> = any,\r\n  EntryInputType extends Record<string, any> = EntryResultType,\r\n> extends ArangoCollection {\r\n  /**\r\n   * Database this collection belongs to.\r\n   */\r\n  readonly database: databases.Database;\r\n  //#region Collection operations\r\n  /**\r\n   * Checks whether the collection exists.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const result = await collection.exists();\r\n   * // result indicates whether the collection exists\r\n   * ```\r\n   */\r\n  exists(): Promise<boolean>;\r\n  /**\r\n   * Retrieves general information about the collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const data = await collection.get();\r\n   * // data contains general information about the collection\r\n   * ```\r\n   */\r\n  get(): Promise<connection.ArangoApiResponse<CollectionDescription>>;\r\n  /**\r\n   * Creates a collection with the given `options` and the instance's name.\r\n   *\r\n   * See also {@link databases.Database#createCollection} and\r\n   * {@link databases.Database#createEdgeCollection}.\r\n   *\r\n   * **Note**: When called on an {@link EdgeCollection} instance in TypeScript,\r\n   * the `type` option must still be set to the correct {@link CollectionType}.\r\n   * Otherwise this will result in the collection being created with the\r\n   * default type (i.e. as a document collection).\r\n   *\r\n   * @param options - Options for creating the collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"potatoes\");\r\n   * await collection.create();\r\n   * // the document collection \"potatoes\" now exists\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * await collection.create({ type: CollectionType.EDGE_COLLECTION });\r\n   * // the edge collection \"friends\" now exists\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * interface Friend {\r\n   *   startDate: number;\r\n   *   endDate?: number;\r\n   * }\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\") as EdgeCollection<Friend>;\r\n   * // even in TypeScript you still need to indicate the collection type\r\n   * // if you want to create an edge collection\r\n   * await collection.create({ type: CollectionType.EDGE_COLLECTION });\r\n   * // the edge collection \"friends\" now exists\r\n   * ```\r\n   */\r\n  create(\r\n    options?: CreateCollectionOptions & {\r\n      type?: CollectionType;\r\n    }\r\n  ): Promise<\r\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\r\n  >;\r\n  /**\r\n   * Retrieves the collection's properties.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const data = await collection.properties();\r\n   * // data contains the collection's properties\r\n   * ```\r\n   */\r\n  properties(): Promise<\r\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\r\n  >;\r\n  /**\r\n   * Replaces the properties of the collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const result = await collection.properties({ waitForSync: true });\r\n   * // the collection will now wait for data being written to disk\r\n   * // whenever a document is changed\r\n   * ```\r\n   */\r\n  properties(\r\n    properties: CollectionPropertiesOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\r\n  >;\r\n  /**\r\n   * Retrieves information about the number of documents in a collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const data = await collection.count();\r\n   * // data contains the collection's count\r\n   * ```\r\n   */\r\n  count(): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & CollectionProperties & { count: number }\r\n    >\r\n  >;\r\n  /**\r\n   * Instructs ArangoDB to recalculate the collection's document count to fix\r\n   * any inconsistencies.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"inconsistent-collection\");\r\n   * const badData = await collection.count();\r\n   * // oh no, the collection count looks wrong -- fix it!\r\n   * await collection.recalculateCount();\r\n   * const goodData = await collection.count();\r\n   * // goodData contains the collection's improved count\r\n   * ```\r\n   */\r\n  recalculateCount(): Promise<boolean>;\r\n  /**\r\n   * Retrieves statistics for a collection.\r\n   *\r\n   * @param details - whether to return extended storage engine-specific details\r\n   * to the figures, which may cause additional load and impact performance\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const data = await collection.figures();\r\n   * // data contains the collection's figures\r\n   * ```\r\n   */\r\n  figures(\r\n    details?: boolean\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription &\r\n        CollectionProperties & { count: number; figures: Record<string, any> }\r\n    >\r\n  >;\r\n  /**\r\n   * Retrieves the collection revision ID.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const data = await collection.revision();\r\n   * // data contains the collection's revision\r\n   * ```\r\n   */\r\n  revision(): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & CollectionProperties & { revision: string }\r\n    >\r\n  >;\r\n  /**\r\n   * Retrieves the collection checksum.\r\n   *\r\n   * @param options - Options for retrieving the checksum.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const data = await collection.checksum();\r\n   * // data contains the collection's checksum\r\n   * ```\r\n   */\r\n  checksum(\r\n    options?: CollectionChecksumOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & { revision: string; checksum: string }\r\n    >\r\n  >;\r\n  /**\r\n   * Retrieves the collection's shard IDs.\r\n   *\r\n   * @param details - If set to `true`, the response will include the responsible\r\n   * servers for each shard.\r\n   */\r\n  shards(\r\n    details?: false\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & CollectionProperties & { shards: string[] }\r\n    >\r\n  >;\r\n  /**\r\n   * Retrieves the collection's shard IDs and the responsible servers for each\r\n   * shard.\r\n   *\r\n   * @param details - If set to `false`, the response will only include the\r\n   * shard IDs without the responsible servers for each shard.\r\n   */\r\n  shards(\r\n    details: true\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription &\r\n        CollectionProperties & { shards: Record<string, string[]> }\r\n    >\r\n  >;\r\n  /**\r\n   * Retrieves the collection's shard IDs.\r\n   *\r\n   * @param details - If set to `true`, the response will include the responsible\r\n   * servers for each shard.\r\n   */\r\n  shards(\r\n    details?: false\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & CollectionProperties & { shards: string[] }\r\n    >\r\n  >;\r\n  /**\r\n   * Retrieves the collection's shard IDs and the responsible servers for each\r\n   * shard.\r\n   *\r\n   * @param details - If set to `false`, the response will only include the\r\n   * shard IDs without the responsible servers for each shard.\r\n   */\r\n  shards(\r\n    details: true\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription &\r\n        CollectionProperties & { shards: Record<string, string[]> }\r\n    >\r\n  >;\r\n  /**\r\n   * Renames the collection and updates the instance's `name` to `newName`.\r\n   *\r\n   * Additionally removes the instance from the {@link databases.Database}'s internal\r\n   * cache.\r\n   *\r\n   * **Note**: Renaming collections may not be supported when ArangoDB is\r\n   * running in a cluster configuration.\r\n   *\r\n   * @param newName - The new name of the collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection1 = db.collection(\"some-collection\");\r\n   * await collection1.rename(\"other-collection\");\r\n   * const collection2 = db.collection(\"some-collection\");\r\n   * const collection3 = db.collection(\"other-collection\");\r\n   * // Note all three collection instances are different objects but\r\n   * // collection1 and collection3 represent the same ArangoDB collection!\r\n   * ```\r\n   */\r\n  rename(\r\n    newName: string\r\n  ): Promise<connection.ArangoApiResponse<CollectionDescription>>;\r\n  /**\r\n   * Deletes all documents in the collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.truncate();\r\n   * // millions of documents cry out in terror and are suddenly silenced,\r\n   * // the collection \"some-collection\" is now empty\r\n   * ```\r\n   */\r\n  truncate(\r\n    options?: TruncateCollectionOptions\r\n  ): Promise<connection.ArangoApiResponse<CollectionDescription>>;\r\n  /**\r\n   * Deletes the collection from the database.\r\n   *\r\n   * @param options - Options for dropping the collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.drop();\r\n   * // The collection \"some-collection\" is now an ex-collection\r\n   * ```\r\n   */\r\n  drop(\r\n    options?: DropCollectionOptions\r\n  ): Promise<connection.ArangoApiResponse<{ id: string }>>;\r\n  /**\r\n   * Triggers compaction for a collection.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.compact();\r\n   * // Background compaction is triggered on the collection\r\n   * ```\r\n   */\r\n  compact(): Promise<connection.ArangoApiResponse<CollectionDescription>>;\r\n  //#endregion\r\n\r\n  //#region Document operations\r\n  /**\r\n   * Retrieves the `shardId` of the shard responsible for the given document.\r\n   *\r\n   * @param document - Document in the collection to look up the `shardId` of.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const responsibleShard = await collection.getResponsibleShard();\r\n   * ```\r\n   */\r\n  getResponsibleShard(\r\n    document: Partial<documents.Document<EntryResultType>>\r\n  ): Promise<string>;\r\n  /**\r\n   * Derives a document `_id` from the given selector for this collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const meta = await collection.save({ foo: \"bar\" }, { returnNew: true });\r\n   * const doc = meta.new;\r\n   * console.log(collection.documentId(meta)); // via meta._id\r\n   * console.log(collection.documentId(doc)); // via doc._id\r\n   * console.log(collection.documentId(meta._key)); // also works\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection1 = db.collection(\"some-collection\");\r\n   * const collection2 = db.collection(\"other-collection\");\r\n   * const meta = await collection1.save({ foo: \"bar\" });\r\n   * // Mixing collections is usually a mistake\r\n   * console.log(collection1.documentId(meta)); // ok: same collection\r\n   * console.log(collection2.documentId(meta)); // throws: wrong collection\r\n   * console.log(collection2.documentId(meta._id)); // also throws\r\n   * console.log(collection2.documentId(meta._key)); // ok but wrong collection\r\n   * ```\r\n   */\r\n  documentId(selector: documents.DocumentSelector): string;\r\n  /**\r\n   * Checks whether a document matching the given key or id exists in this\r\n   * collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const exists = await collection.documentExists(\"abc123\");\r\n   * if (!exists) {\r\n   *   console.log(\"Document does not exist\");\r\n   * }\r\n   * ```\r\n   */\r\n  documentExists(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.DocumentExistsOptions\r\n  ): Promise<boolean>;\r\n  /**\r\n   * Retrieves the document matching the given key or id.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param options - Options for retrieving the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * try {\r\n   *   const document = await collection.document(\"abc123\");\r\n   *   console.log(document);\r\n   * } catch (e: any) {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const document = await collection.document(\"abc123\", { graceful: true });\r\n   * if (document) {\r\n   *   console.log(document);\r\n   * } else {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   */\r\n  document(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.ReadDocumentOptions\r\n  ): Promise<documents.Document<EntryResultType>>;\r\n  /**\r\n   * Retrieves the document matching the given key or id.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param graceful - If set to `true`, `null` is returned instead of an\r\n   * exception being thrown if the document does not exist.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * try {\r\n   *   const document = await collection.document(\"abc123\", false);\r\n   *   console.log(document);\r\n   * } catch (e: any) {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const document = await collection.document(\"abc123\", true);\r\n   * if (document) {\r\n   *   console.log(document);\r\n   * } else {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   */\r\n  document(\r\n    selector: documents.DocumentSelector,\r\n    graceful: boolean\r\n  ): Promise<documents.Document<EntryResultType>>;\r\n  /**\r\n   * Retrieves the documents matching the given key or id values.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection, or if the document does not exist.\r\n   *\r\n   * @param selectors - Array of document `_key`, `_id` or objects with either\r\n   * of those properties (e.g. a document from this collection).\r\n   * @param options - Options for retrieving the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * try {\r\n   *   const documents = await collection.documents([\"abc123\", \"xyz456\"]);\r\n   *   console.log(documents);\r\n   * } catch (e: any) {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   */\r\n  documents(\r\n    selectors: (string | documents.ObjectWithDocumentKey)[],\r\n    options?: documents.BulkReadDocumentsOptions\r\n  ): Promise<documents.Document<EntryResultType>[]>;\r\n  /**\r\n   * Inserts a new document with the given `data` into the collection.\r\n   *\r\n   * @param data - The contents of the new document.\r\n   * @param options - Options for inserting the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const result = await collection.save(\r\n   *   { _key: \"a\", color: \"blue\", count: 1 },\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result.new.color, result.new.count); // \"blue\" 1\r\n   * ```\r\n   */\r\n  save(\r\n    data: documents.DocumentData<EntryInputType>,\r\n    options?: documents.InsertDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentOperationMetadata & {\r\n      new?: documents.Document<EntryResultType>;\r\n      old?: documents.Document<EntryResultType>;\r\n    }\r\n  >;\r\n  /**\r\n   * Inserts new documents with the given `data` into the collection.\r\n   *\r\n   * @param data - The contents of the new documents.\r\n   * @param options - Options for inserting the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const result = await collection.saveAll(\r\n   *   [\r\n   *     { _key: \"a\", color: \"blue\", count: 1 },\r\n   *     { _key: \"b\", color: \"red\", count: 2 },\r\n   *   ],\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result[0].new.color, result[0].new.count); // \"blue\" 1\r\n   * console.log(result[1].new.color, result[1].new.count); // \"red\" 2\r\n   * ```\r\n   */\r\n  saveAll(\r\n    data: Array<documents.DocumentData<EntryInputType>>,\r\n    options?: documents.InsertDocumentOptions\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentOperationMetadata & {\r\n          new?: documents.Document<EntryResultType>;\r\n          old?: documents.Document<EntryResultType>;\r\n        })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Replaces an existing document in the collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param newData - The contents of the new document.\r\n   * @param options - Options for replacing the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\r\n   * const result = await collection.replace(\r\n   *   \"a\",\r\n   *   { color: \"red\" },\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result.new.color, result.new.count); // \"red\" undefined\r\n   * ```\r\n   */\r\n  replace(\r\n    selector: documents.DocumentSelector,\r\n    newData: documents.DocumentData<EntryInputType>,\r\n    options?: documents.ReplaceDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentOperationMetadata & {\r\n      new?: documents.Document<EntryResultType>;\r\n      old?: documents.Document<EntryResultType>;\r\n    }\r\n  >;\r\n  /**\r\n   * Replaces existing documents in the collection, identified by the `_key` or\r\n   * `_id` of each document.\r\n   *\r\n   * @param newData - The documents to replace.\r\n   * @param options - Options for replacing the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\r\n   * await collection.save({ _key: \"b\", color: \"green\", count: 3 });\r\n   * const result = await collection.replaceAll(\r\n   *   [\r\n   *     { _key: \"a\", color: \"red\" },\r\n   *     { _key: \"b\", color: \"yellow\", count: 2 }\r\n   *   ],\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result[0].new.color, result[0].new.count); // \"red\" undefined\r\n   * console.log(result[1].new.color, result[1].new.count); // \"yellow\" 2\r\n   * ```\r\n   */\r\n  replaceAll(\r\n    newData: Array<\r\n      documents.DocumentData<EntryInputType> &\r\n        ({ _key: string } | { _id: string })\r\n    >,\r\n    options?: Omit<documents.ReplaceDocumentOptions, \"ifMatch\">\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentOperationMetadata & {\r\n          new?: documents.Document<EntryResultType>;\r\n          old?: documents.Document<EntryResultType>;\r\n        })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Updates an existing document in the collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param newData - The data for updating the document.\r\n   * @param options - Options for updating the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\r\n   * const result = await collection.update(\r\n   *   \"a\",\r\n   *   { count: 2 },\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result.new.color, result.new.count); // \"blue\" 2\r\n   * ```\r\n   */\r\n  update(\r\n    selector: documents.DocumentSelector,\r\n    newData: documents.Patch<documents.DocumentData<EntryInputType>>,\r\n    options?: documents.UpdateDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentOperationMetadata & {\r\n      new?: documents.Document<EntryResultType>;\r\n      old?: documents.Document<EntryResultType>;\r\n    }\r\n  >;\r\n  /**\r\n   * Updates existing documents in the collection, identified by the `_key` or\r\n   * `_id` of each document.\r\n   *\r\n   * @param newData - The data for updating the documents.\r\n   * @param options - Options for updating the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.save({ _key: \"a\", color: \"blue\", count: 1 });\r\n   * await collection.save({ _key: \"b\", color: \"green\", count: 3 });\r\n   * const result = await collection.updateAll(\r\n   *   [\r\n   *     { _key: \"a\", count: 2 },\r\n   *     { _key: \"b\", count: 4 }\r\n   *   ],\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result[0].new.color, result[0].new.count); // \"blue\" 2\r\n   * console.log(result[1].new.color, result[1].new.count); // \"green\" 4\r\n   * ```\r\n   */\r\n  updateAll(\r\n    newData: Array<\r\n      documents.Patch<documents.DocumentData<EntryInputType>> &\r\n        ({ _key: string } | { _id: string })\r\n    >,\r\n    options?: Omit<documents.UpdateDocumentOptions, \"ifMatch\">\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentOperationMetadata & {\r\n          new?: documents.Document<EntryResultType>;\r\n          old?: documents.Document<EntryResultType>;\r\n        })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Removes an existing document from the collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param options - Options for removing the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.remove(\"abc123\");\r\n   * // document with key \"abc123\" deleted\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const doc = await collection.document(\"abc123\");\r\n   * await collection.remove(doc);\r\n   * // document with key \"abc123\" deleted\r\n   * ```\r\n   */\r\n  remove(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.RemoveDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentMetadata & { old?: documents.Document<EntryResultType> }\r\n  >;\r\n  /**\r\n   * Removes existing documents from the collection.\r\n   *\r\n   * Throws an exception when passed any document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selectors - Documents `_key`, `_id` or objects with either of those\r\n   * properties (e.g. documents from this collection).\r\n   * @param options - Options for removing the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.removeAll([\"abc123\", \"def456\"]);\r\n   * // document with keys \"abc123\" and \"def456\" deleted\r\n   * ```\r\n   */\r\n  removeAll(\r\n    selectors: (string | documents.ObjectWithDocumentKey)[],\r\n    options?: Omit<documents.RemoveDocumentOptions, \"ifMatch\">\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentMetadata & {\r\n          old?: documents.Document<EntryResultType>;\r\n        })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Bulk imports the given `data` into the collection.\r\n   *\r\n   * @param data - The data to import, as an array of document data.\r\n   * @param options - Options for importing the data.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   [\r\n   *     { _key: \"jcd\", password: \"bionicman\" },\r\n   *     { _key: \"jreyes\", password: \"amigo\" },\r\n   *     { _key: \"ghermann\", password: \"zeitgeist\" }\r\n   *   ]\r\n   * );\r\n   * ```\r\n   */\r\n  import(\r\n    data: documents.DocumentData<EntryInputType>[],\r\n    options?: documents.ImportDocumentsOptions\r\n  ): Promise<documents.ImportDocumentsResult>;\r\n  /**\r\n   * Bulk imports the given `data` into the collection.\r\n   *\r\n   * @param data - The data to import, as an array containing a single array of\r\n   * attribute names followed by one or more arrays of attribute values for\r\n   * each document.\r\n   * @param options - Options for importing the data.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   [\r\n   *     [ \"_key\", \"password\" ],\r\n   *     [ \"jcd\", \"bionicman\" ],\r\n   *     [ \"jreyes\", \"amigo\" ],\r\n   *     [ \"ghermann\", \"zeitgeist\" ]\r\n   *   ]\r\n   * );\r\n   * ```\r\n   */\r\n  import(\r\n    data: any[][],\r\n    options?: documents.ImportDocumentsOptions\r\n  ): Promise<documents.ImportDocumentsResult>;\r\n  /**\r\n   * Bulk imports the given `data` into the collection.\r\n   *\r\n   * If `type` is omitted, `data` must contain one JSON array per line with\r\n   * the first array providing the attribute names and all other arrays\r\n   * providing attribute values for each document.\r\n   *\r\n   * If `type` is set to `\"documents\"`, `data` must contain one JSON document\r\n   * per line.\r\n   *\r\n   * If `type` is set to `\"list\"`, `data` must contain a JSON array of\r\n   * documents.\r\n   *\r\n   * If `type` is set to `\"auto\"`, `data` can be in either of the formats\r\n   * supported by `\"documents\"` or `\"list\"`.\r\n   *\r\n   * @param data - The data to import as a Buffer (Node), Blob (browser) or\r\n   * string.\r\n   * @param options - Options for importing the data.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   '{\"_key\":\"jcd\",\"password\":\"bionicman\"}\\r\\n' +\r\n   *   '{\"_key\":\"jreyes\",\"password\":\"amigo\"}\\r\\n' +\r\n   *   '{\"_key\":\"ghermann\",\"password\":\"zeitgeist\"}\\r\\n',\r\n   *   { type: \"documents\" } // or \"auto\"\r\n   * );\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   '[{\"_key\":\"jcd\",\"password\":\"bionicman\"},' +\r\n   *   '{\"_key\":\"jreyes\",\"password\":\"amigo\"},' +\r\n   *   '{\"_key\":\"ghermann\",\"password\":\"zeitgeist\"}]',\r\n   *   { type: \"list\" } // or \"auto\"\r\n   * );\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   '[\"_key\",\"password\"]\\r\\n' +\r\n   *   '[\"jcd\",\"bionicman\"]\\r\\n' +\r\n   *   '[\"jreyes\",\"amigo\"]\\r\\n' +\r\n   *   '[\"ghermann\",\"zeitgeist\"]\\r\\n'\r\n   * );\r\n   * ```\r\n   */\r\n  import(\r\n    data: Buffer | Blob | string,\r\n    options?: documents.ImportDocumentsOptions & {\r\n      type?: \"\" | \"documents\" | \"list\" | \"auto\";\r\n    }\r\n  ): Promise<documents.ImportDocumentsResult>;\r\n  //#endregion\r\n\r\n  //#region Index operations\r\n  /**\r\n   * Instructs ArangoDB to load as many indexes of the collection into memory\r\n   * as permitted by the memory limit.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"indexed-collection\");\r\n   * await collection.loadIndexes();\r\n   * // the indexes are now loaded into memory\r\n   * ```\r\n   */\r\n  loadIndexes(): Promise<boolean>;\r\n  /**\r\n   * Returns a list of all index descriptions for the collection.\r\n   *\r\n   * @param options - Options for fetching the index list.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const indexes = await collection.indexes();\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const allIndexes = await collection.indexes<HiddenIndexDescription>({\r\n   *   withHidden: true\r\n   * });\r\n   * ```\r\n   */\r\n  indexes<\r\n    IndexType extends\r\n      | indexes.IndexDescription\r\n      | indexes.HiddenIndexDescription = indexes.IndexDescription,\r\n  >(\r\n    options?: indexes.ListIndexesOptions\r\n  ): Promise<IndexType[]>;\r\n  /**\r\n   * Returns an index description by name or `id` if it exists.\r\n   *\r\n   * @param selector - Index name, id or object with either property.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const index = await collection.index(\"some-index\");\r\n   * ```\r\n   */\r\n  index(selector: indexes.IndexSelector): Promise<indexes.IndexDescription>;\r\n  /**\r\n   * Creates a persistent index on the collection if it does not already exist.\r\n   *\r\n   * @param options - Options for creating the persistent index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * // Create a unique index for looking up documents by username\r\n   * await collection.ensureIndex({\r\n   *   type: \"persistent\",\r\n   *   fields: [\"username\"],\r\n   *   name: \"unique-usernames\",\r\n   *   unique: true\r\n   * });\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    options: indexes.EnsurePersistentIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.PersistentIndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Creates a TTL index on the collection if it does not already exist.\r\n   *\r\n   * @param options - Options for creating the TTL index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * // Expire documents with \"createdAt\" timestamp one day after creation\r\n   * await collection.ensureIndex({\r\n   *   type: \"ttl\",\r\n   *   fields: [\"createdAt\"],\r\n   *   expireAfter: 60 * 60 * 24 // 24 hours\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * // Expire documents with \"expiresAt\" timestamp according to their value\r\n   * await collection.ensureIndex({\r\n   *   type: \"ttl\",\r\n   *   fields: [\"expiresAt\"],\r\n   *   expireAfter: 0 // when attribute value is exceeded\r\n   * });\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    options: indexes.EnsureTtlIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.TtlIndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Creates a multi-dimensional index on the collection if it does not already exist.\r\n   *\r\n   * @param options - Options for creating the multi-dimensional index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-points\");\r\n   * // Create a multi-dimensional index for the attributes x, y and z\r\n   * await collection.ensureIndex({\r\n   *   type: \"mdi\",\r\n   *   fields: [\"x\", \"y\", \"z\"],\r\n   *   fieldValueTypes: \"double\"\r\n   * });\r\n   * ```\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    options: indexes.EnsureMdiIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.MdiIndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Creates a prefixed multi-dimensional index on the collection if it does not already exist.\r\n   *\r\n   * @param details - Options for creating the prefixed multi-dimensional index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-points\");\r\n   * // Create a multi-dimensional index for the attributes x, y and z\r\n   * await collection.ensureIndex({\r\n   *   type: \"mdi-prefixed\",\r\n   *   fields: [\"x\", \"y\", \"z\"],\r\n   *   prefixFields: [\"x\"],\r\n   *   fieldValueTypes: \"double\"\r\n   * });\r\n   * ```\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    details: indexes.EnsureMdiPrefixedIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.MdiPrefixedIndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Creates a geo index on the collection if it does not already exist.\r\n   *\r\n   * @param options - Options for creating the geo index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * // Create an index for GeoJSON data\r\n   * await collection.ensureIndex({\r\n   *   type: \"geo\",\r\n   *   fields: [\"lngLat\"],\r\n   *   geoJson: true\r\n   * });\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    options: indexes.EnsureGeoIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.GeoIndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Creates a inverted index on the collection if it does not already exist.\r\n   *\r\n   * @param options - Options for creating the inverted index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * // Create an inverted index\r\n   * await collection.ensureIndex({\r\n   *   type: \"inverted\",\r\n   *   fields: [\"a\", { name: \"b\", analyzer: \"text_en\" }]\r\n   * });\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    options: indexes.EnsureInvertedIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.InvertedIndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Creates a vector index on the collection if it does not already exist.\r\n   *\r\n   * @param options - Options for creating the vector index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.ensureIndex({\r\n   *   type: \"vector\",\r\n   *   fields: [\"embedding\"],\r\n   *   params: {\r\n   *     metric: \"cosine\",\r\n   *     dimension: 128,\r\n   *     nLists: 100\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    options: indexes.EnsureVectorIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.VectorIndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Creates an index on the collection if it does not already exist.\r\n   *\r\n   * @param options - Options for creating the index.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * // Create a unique index for looking up documents by username\r\n   * await collection.ensureIndex({\r\n   *   type: \"persistent\",\r\n   *   fields: [\"username\"],\r\n   *   name: \"unique-usernames\",\r\n   *   unique: true\r\n   * });\r\n   * ```\r\n   */\r\n  ensureIndex(\r\n    options: indexes.EnsureIndexOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      indexes.IndexDescription & { isNewlyCreated: boolean }\r\n    >\r\n  >;\r\n  /**\r\n   * Deletes the index with the given name or `id` from the database.\r\n   *\r\n   * @param selector - Index name, id or object with either property.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.dropIndex(\"some-index\");\r\n   * // The index \"some-index\" no longer exists\r\n   * ```\r\n   */\r\n  dropIndex(\r\n    selector: indexes.IndexSelector\r\n  ): Promise<connection.ArangoApiResponse<{ id: string }>>;\r\n  //#endregion\r\n}\r\n//#endregion\r\n\r\n//#region EdgeCollection interface\r\n/**\r\n * Represents an edge collection in a {@link databases.Database}.\r\n *\r\n * See {@link DocumentCollection} for a more generic variant of this interface\r\n * more suited for regular document collections.\r\n *\r\n * See also {@link graphs.GraphEdgeCollection} for the type representing an edge\r\n * collection in a {@link graphs.Graph}.\r\n *\r\n * When using TypeScript, collections can be cast to a specific edge document\r\n * data type to increase type safety.\r\n *\r\n * @param EntryResultType - Type to represent edge document contents returned\r\n * by the server (including computed properties).\r\n * @param EntryInputType - Type to represent edge document contents passed when\r\n * inserting or replacing edge documents (without computed properties).\r\n *\r\n * @example\r\n * ```ts\r\n * interface Friend {\r\n *   startDate: number;\r\n *   endDate?: number;\r\n * }\r\n * const db = new Database();\r\n * const edges = db.collection(\"friends\") as EdgeCollection<Friend>;\r\n * ```\r\n */\r\nexport interface EdgeCollection<\r\n  EntryResultType extends Record<string, any> = any,\r\n  EntryInputType extends Record<string, any> = EntryResultType,\r\n> extends DocumentCollection<EntryResultType, EntryInputType> {\r\n  //#region Document operations\r\n  /**\r\n   * Retrieves the document matching the given key or id.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection, or if the document does not exist.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param options - Options for retrieving the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * try {\r\n   *   const document = await collection.document(\"abc123\");\r\n   *   console.log(document);\r\n   * } catch (e: any) {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const document = await collection.document(\"abc123\", { graceful: true });\r\n   * if (document) {\r\n   *   console.log(document);\r\n   * } else {\r\n   *   console.error(\"Document does not exist\");\r\n   * }\r\n   * ```\r\n   */\r\n  document(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.ReadDocumentOptions\r\n  ): Promise<documents.Edge<EntryResultType>>;\r\n  /**\r\n   * Retrieves the document matching the given key or id.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection, or if the document does not exist.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param graceful - If set to `true`, `null` is returned instead of an\r\n   * exception being thrown if the document does not exist.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * try {\r\n   *   const document = await collection.document(\"abc123\", false);\r\n   *   console.log(document);\r\n   * } catch (e: any) {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * const document = await collection.document(\"abc123\", true);\r\n   * if (document) {\r\n   *   console.log(document);\r\n   * } else {\r\n   *   console.error(\"Document does not exist\");\r\n   * }\r\n   * ```\r\n   */\r\n  document(\r\n    selector: documents.DocumentSelector,\r\n    graceful: boolean\r\n  ): Promise<documents.Edge<EntryResultType>>;\r\n  /**\r\n   * Retrieves the documents matching the given key or id values.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection, or if the document does not exist.\r\n   *\r\n   * @param selectors - Array of document `_key`, `_id` or objects with either\r\n   * of those properties (e.g. a document from this collection).\r\n   * @param options - Options for retrieving the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * try {\r\n   *   const documents = await collection.documents([\"abc123\", \"xyz456\"]);\r\n   *   console.log(documents);\r\n   * } catch (e: any) {\r\n   *   console.error(\"Could not find document\");\r\n   * }\r\n   * ```\r\n   */\r\n  documents(\r\n    selectors: (string | documents.ObjectWithDocumentKey)[],\r\n    options?: documents.BulkReadDocumentsOptions\r\n  ): Promise<documents.Edge<EntryResultType>[]>;\r\n  /**\r\n   * Inserts a new document with the given `data` into the collection.\r\n   *\r\n   * @param data - The contents of the new document.\r\n   * @param options - Options for inserting the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * const result = await collection.save(\r\n   *   { _from: \"users/rana\", _to: \"users/mudasir\", active: false },\r\n   *   { returnNew: true }\r\n   * );\r\n   * ```\r\n   */\r\n  save(\r\n    data: documents.EdgeData<EntryInputType>,\r\n    options?: documents.InsertDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentOperationMetadata & {\r\n      new?: documents.Edge<EntryResultType>;\r\n      old?: documents.Edge<EntryResultType>;\r\n    }\r\n  >;\r\n  /**\r\n   * Inserts new documents with the given `data` into the collection.\r\n   *\r\n   * @param data - The contents of the new documents.\r\n   * @param options - Options for inserting the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * const result = await collection.saveAll(\r\n   *   [\r\n   *     { _from: \"users/rana\", _to: \"users/mudasir\", active: false },\r\n   *     { _from: \"users/rana\", _to: \"users/salman\", active: true }\r\n   *   ],\r\n   *   { returnNew: true }\r\n   * );\r\n   * ```\r\n   */\r\n  saveAll(\r\n    data: Array<documents.EdgeData<EntryInputType>>,\r\n    options?: documents.InsertDocumentOptions\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentOperationMetadata & {\r\n          new?: documents.Edge<EntryResultType>;\r\n          old?: documents.Edge<EntryResultType>;\r\n        })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Replaces an existing document in the collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param newData - The contents of the new document.\r\n   * @param options - Options for replacing the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * await collection.save(\r\n   *   {\r\n   *     _key: \"musadir\",\r\n   *     _from: \"users/rana\",\r\n   *     _to: \"users/mudasir\",\r\n   *     active: true,\r\n   *     best: true\r\n   *   }\r\n   * );\r\n   * const result = await collection.replace(\r\n   *   \"musadir\",\r\n   *   { active: false },\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result.new.active, result.new.best); // false undefined\r\n   * ```\r\n   */\r\n  replace(\r\n    selector: documents.DocumentSelector,\r\n    newData: documents.DocumentData<EntryInputType>,\r\n    options?: documents.ReplaceDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentOperationMetadata & {\r\n      new?: documents.Edge<EntryResultType>;\r\n      old?: documents.Edge<EntryResultType>;\r\n    }\r\n  >;\r\n  /**\r\n   * Replaces existing documents in the collection, identified by the `_key` or\r\n   * `_id` of each document.\r\n   *\r\n   * @param newData - The documents to replace.\r\n   * @param options - Options for replacing the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * await collection.save(\r\n   *   {\r\n   *     _key: \"musadir\",\r\n   *     _from: \"users/rana\",\r\n   *     _to: \"users/mudasir\",\r\n   *     active: true,\r\n   *     best: true\r\n   *   }\r\n   * );\r\n   * await collection.save(\r\n   *   {\r\n   *     _key: \"salman\",\r\n   *     _from: \"users/rana\",\r\n   *     _to: \"users/salman\",\r\n   *     active: false,\r\n   *     best: false\r\n   *   }\r\n   * );\r\n   * const result = await collection.replaceAll(\r\n   *   [\r\n   *     { _key: \"musadir\", active: false },\r\n   *     { _key: \"salman\", active: true, best: true }\r\n   *   ],\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result[0].new.active, result[0].new.best); // false undefined\r\n   * console.log(result[1].new.active, result[1].new.best); // true true\r\n   * ```\r\n   */\r\n  replaceAll(\r\n    newData: Array<\r\n      documents.DocumentData<EntryInputType> &\r\n        ({ _key: string } | { _id: string })\r\n    >,\r\n    options?: documents.ReplaceDocumentOptions\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentOperationMetadata & {\r\n          new?: documents.Edge<EntryResultType>;\r\n          old?: documents.Edge<EntryResultType>;\r\n        })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Updates an existing document in the collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param newData - The data for updating the document.\r\n   * @param options - Options for updating the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * await collection.save(\r\n   *   {\r\n   *     _key: \"musadir\",\r\n   *     _from: \"users/rana\",\r\n   *     _to: \"users/mudasir\",\r\n   *     active: true,\r\n   *     best: true\r\n   *   }\r\n   * );\r\n   * const result = await collection.update(\r\n   *   \"musadir\",\r\n   *   { active: false },\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result.new.active, result.new.best); // false true\r\n   * ```\r\n   */\r\n  update(\r\n    selector: documents.DocumentSelector,\r\n    newData: documents.Patch<documents.DocumentData<EntryInputType>>,\r\n    options?: documents.UpdateDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentOperationMetadata & {\r\n      new?: documents.Edge<EntryResultType>;\r\n      old?: documents.Edge<EntryResultType>;\r\n    }\r\n  >;\r\n  /**\r\n   * Updates existing documents in the collection, identified by the `_key` or\r\n   * `_id` of each document.\r\n   *\r\n   * @param newData - The data for updating the documents.\r\n   * @param options - Options for updating the documents.\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * await collection.save(\r\n   *   {\r\n   *     _key: \"musadir\",\r\n   *     _from: \"users/rana\",\r\n   *     _to: \"users/mudasir\",\r\n   *     active: true,\r\n   *     best: true\r\n   *   }\r\n   * );\r\n   * await collection.save(\r\n   *   {\r\n   *     _key: \"salman\",\r\n   *     _from: \"users/rana\",\r\n   *     _to: \"users/salman\",\r\n   *     active: false,\r\n   *     best: false\r\n   *   }\r\n   * );\r\n   * const result = await collection.updateAll(\r\n   *   [\r\n   *     { _key: \"musadir\", active: false },\r\n   *     { _key: \"salman\", active: true, best: true }\r\n   *   ],\r\n   *   { returnNew: true }\r\n   * );\r\n   * console.log(result[0].new.active, result[0].new.best); // false true\r\n   * console.log(result[1].new.active, result[1].new.best); // true true\r\n   * ```\r\n   */\r\n  updateAll(\r\n    newData: Array<\r\n      documents.Patch<documents.DocumentData<EntryInputType>> &\r\n        ({ _key: string } | { _id: string })\r\n    >,\r\n    options?: documents.UpdateDocumentOptions\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentOperationMetadata & {\r\n          new?: documents.Edge<EntryResultType>;\r\n          old?: documents.Edge<EntryResultType>;\r\n        })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Removes an existing document from the collection.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param options - Options for removing the document.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * const doc = await collection.document(\"musadir\");\r\n   * await collection.remove(doc);\r\n   * // document with key \"musadir\" deleted\r\n   * ```\r\n   */\r\n  remove(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.RemoveDocumentOptions\r\n  ): Promise<\r\n    documents.DocumentMetadata & { old?: documents.Edge<EntryResultType> }\r\n  >;\r\n  /**\r\n   * Removes existing documents from the collection.\r\n   *\r\n   * Throws an exception when passed any document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selectors - Documents `_key`, `_id` or objects with either of those\r\n   * properties (e.g. documents from this collection).\r\n   * @param options - Options for removing the documents.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"friends\");\r\n   * await collection.removeAll([\"musadir\", \"salman\"]);\r\n   * // document with keys \"musadir\" and \"salman\" deleted\r\n   * ```\r\n   */\r\n  removeAll(\r\n    selectors: documents.DocumentSelector[],\r\n    options?: documents.RemoveDocumentOptions\r\n  ): Promise<\r\n    Array<\r\n      | (documents.DocumentMetadata & { old?: documents.Edge<EntryResultType> })\r\n      | documents.DocumentOperationFailure\r\n    >\r\n  >;\r\n  /**\r\n   * Bulk imports the given `data` into the collection.\r\n   *\r\n   * @param data - The data to import, as an array of edge data.\r\n   * @param options - Options for importing the data.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   [\r\n   *     { _key: \"x\", _from: \"vertices/a\", _to: \"vertices/b\", weight: 1 },\r\n   *     { _key: \"y\", _from: \"vertices/a\", _to: \"vertices/c\", weight: 2 }\r\n   *   ]\r\n   * );\r\n   * ```\r\n   */\r\n  import(\r\n    data: documents.EdgeData<EntryInputType>[],\r\n    options?: documents.ImportDocumentsOptions\r\n  ): Promise<documents.ImportDocumentsResult>;\r\n  /**\r\n   * Bulk imports the given `data` into the collection.\r\n   *\r\n   * @param data - The data to import, as an array containing a single array of\r\n   * attribute names followed by one or more arrays of attribute values for\r\n   * each edge document.\r\n   * @param options - Options for importing the data.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   [\r\n   *     [ \"_key\", \"_from\", \"_to\", \"weight\" ],\r\n   *     [ \"x\", \"vertices/a\", \"vertices/b\", 1 ],\r\n   *     [ \"y\", \"vertices/a\", \"vertices/c\", 2 ]\r\n   *   ]\r\n   * );\r\n   * ```\r\n   */\r\n  import(\r\n    data: any[][],\r\n    options?: documents.ImportDocumentsOptions\r\n  ): Promise<documents.ImportDocumentsResult>;\r\n  /**\r\n   * Bulk imports the given `data` into the collection.\r\n   *\r\n   * If `type` is omitted, `data` must contain one JSON array per line with\r\n   * the first array providing the attribute names and all other arrays\r\n   * providing attribute values for each edge document.\r\n   *\r\n   * If `type` is set to `\"documents\"`, `data` must contain one JSON document\r\n   * per line.\r\n   *\r\n   * If `type` is set to `\"list\"`, `data` must contain a JSON array of\r\n   * edge documents.\r\n   *\r\n   * If `type` is set to `\"auto\"`, `data` can be in either of the formats\r\n   * supported by `\"documents\"` or `\"list\"`.\r\n   *\r\n   * @param data - The data to import as a Buffer (Node), Blob (browser) or\r\n   * string.\r\n   * @param options - Options for importing the data.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   '{\"_key\":\"x\",\"_from\":\"vertices/a\",\"_to\":\"vertices/b\",\"weight\":1}\\r\\n' +\r\n   *   '{\"_key\":\"y\",\"_from\":\"vertices/a\",\"_to\":\"vertices/c\",\"weight\":2}\\r\\n',\r\n   *   { type: \"documents\" } // or \"auto\"\r\n   * );\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   '[{\"_key\":\"x\",\"_from\":\"vertices/a\",\"_to\":\"vertices/b\",\"weight\":1},' +\r\n   *   '{\"_key\":\"y\",\"_from\":\"vertices/a\",\"_to\":\"vertices/c\",\"weight\":2}]',\r\n   *   { type: \"list\" } // or \"auto\"\r\n   * );\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"some-collection\");\r\n   * await collection.import(\r\n   *   '[\"_key\",\"_from\",\"_to\",\"weight\"]\\r\\n' +\r\n   *   '[\"x\",\"vertices/a\",\"vertices/b\",1]\\r\\n' +\r\n   *   '[\"y\",\"vertices/a\",\"vertices/c\",2]\\r\\n'\r\n   * );\r\n   * ```\r\n   */\r\n  import(\r\n    data: Buffer | Blob | string,\r\n    options?: documents.ImportDocumentsOptions & {\r\n      type?: \"\" | \"documents\" | \"list\" | \"auto\";\r\n    }\r\n  ): Promise<documents.ImportDocumentsResult>;\r\n  //#endregion\r\n\r\n  //#region Edge operations\r\n  /**\r\n   * Retrieves a list of all edges in this collection of the document matching\r\n   * the given `selector`.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param options - Options for retrieving the edges.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"edges\");\r\n   * await collection.import([\r\n   *   [\"_key\", \"_from\", \"_to\"],\r\n   *   [\"x\", \"vertices/a\", \"vertices/b\"],\r\n   *   [\"y\", \"vertices/a\", \"vertices/c\"],\r\n   *   [\"z\", \"vertices/d\", \"vertices/a\"],\r\n   * ]);\r\n   * const edges = await collection.edges(\"vertices/a\");\r\n   * console.log(edges.map((edge) => edge._key)); // [\"x\", \"y\", \"z\"]\r\n   * ```\r\n   */\r\n  edges(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.DocumentEdgesOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<documents.DocumentEdgesResult<EntryResultType>>\r\n  >;\r\n  /**\r\n   * Retrieves a list of all incoming edges of the document matching the given\r\n   * `selector`.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param options - Options for retrieving the edges.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"edges\");\r\n   * await collection.import([\r\n   *   [\"_key\", \"_from\", \"_to\"],\r\n   *   [\"x\", \"vertices/a\", \"vertices/b\"],\r\n   *   [\"y\", \"vertices/a\", \"vertices/c\"],\r\n   *   [\"z\", \"vertices/d\", \"vertices/a\"],\r\n   * ]);\r\n   * const edges = await collection.inEdges(\"vertices/a\");\r\n   * console.log(edges.map((edge) => edge._key)); // [\"z\"]\r\n   * ```\r\n   */\r\n  inEdges(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.DocumentEdgesOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<documents.DocumentEdgesResult<EntryResultType>>\r\n  >;\r\n  /**\r\n   * Retrieves a list of all outgoing edges of the document matching the given\r\n   * `selector`.\r\n   *\r\n   * Throws an exception when passed a document or `_id` from a different\r\n   * collection.\r\n   *\r\n   * @param selector - Document `_key`, `_id` or object with either of those\r\n   * properties (e.g. a document from this collection).\r\n   * @param options - Options for retrieving the edges.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const collection = db.collection(\"edges\");\r\n   * await collection.import([\r\n   *   [\"_key\", \"_from\", \"_to\"],\r\n   *   [\"x\", \"vertices/a\", \"vertices/b\"],\r\n   *   [\"y\", \"vertices/a\", \"vertices/c\"],\r\n   *   [\"z\", \"vertices/d\", \"vertices/a\"],\r\n   * ]);\r\n   * const edges = await collection.outEdges(\"vertices/a\");\r\n   * console.log(edges.map((edge) => edge._key)); // [\"x\", \"y\"]\r\n   * ```\r\n   */\r\n  outEdges(\r\n    selector: documents.DocumentSelector,\r\n    options?: documents.DocumentEdgesOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<documents.DocumentEdgesResult<EntryResultType>>\r\n  >;\r\n  //#endregion\r\n}\r\n//#endregion\r\n\r\n//#region Collection class\r\n/**\r\n * @internal\r\n */\r\nexport class Collection<\r\n    EntryResultType extends Record<string, any> = any,\r\n    EntryInputType extends Record<string, any> = EntryResultType,\r\n  >\r\n  implements\r\n    EdgeCollection<EntryResultType, EntryInputType>,\r\n    DocumentCollection<EntryResultType, EntryInputType>\r\n{\r\n  protected _name: string;\r\n  protected _db: databases.Database;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor(db: databases.Database, name: string) {\r\n    this._name = name;\r\n    this._db = db;\r\n  }\r\n\r\n  get isArangoCollection(): true {\r\n    return true;\r\n  }\r\n\r\n  get database() {\r\n    return this._db;\r\n  }\r\n\r\n  get name() {\r\n    return this._name;\r\n  }\r\n\r\n  //#region Collection operations\r\n  get() {\r\n    return this._db.request({\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}`,\r\n    });\r\n  }\r\n\r\n  async exists() {\r\n    try {\r\n      await this.get();\r\n      return true;\r\n    } catch (err: any) {\r\n      if (errors.isArangoError(err) && err.errorNum === COLLECTION_NOT_FOUND) {\r\n        return false;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  create(\r\n    options: CreateCollectionOptions & {\r\n      type?: CollectionType;\r\n    } = {}\r\n  ) {\r\n    const {\r\n      waitForSyncReplication = undefined,\r\n      enforceReplicationFactor = undefined,\r\n      ...opts\r\n    } = options;\r\n    if (opts.computedValues) {\r\n      opts.computedValues = opts.computedValues.map((computedValue) => {\r\n        if (aql.isAqlLiteral(computedValue.expression)) {\r\n          return {\r\n            ...computedValue,\r\n            expression: computedValue.expression.toAQL(),\r\n          };\r\n        }\r\n        if (aql.isAqlQuery(computedValue.expression)) {\r\n          return {\r\n            ...computedValue,\r\n            expression: computedValue.expression.query,\r\n          };\r\n        }\r\n        return computedValue;\r\n      });\r\n    }\r\n    const search: Record<string, any> = {};\r\n    if (typeof waitForSyncReplication === \"boolean\") {\r\n      search.waitForSyncReplication = waitForSyncReplication ? 1 : 0;\r\n    }\r\n    if (typeof enforceReplicationFactor === \"boolean\") {\r\n      search.enforceReplicationFactor = enforceReplicationFactor ? 1 : 0;\r\n    }\r\n    return this._db.request({\r\n      method: \"POST\",\r\n      pathname: \"/_api/collection\",\r\n      search,\r\n      body: {\r\n        ...opts,\r\n        name: this._name,\r\n      },\r\n    });\r\n  }\r\n\r\n  properties(\r\n    properties?: CollectionPropertiesOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<CollectionDescription & CollectionProperties>\r\n  > {\r\n    if (!properties) {\r\n      return this._db.request({\r\n        pathname: `/_api/collection/${encodeURIComponent(this._name)}/properties`,\r\n      });\r\n    }\r\n    return this._db.request({\r\n      method: \"PUT\",\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/properties`,\r\n      body: properties,\r\n    });\r\n  }\r\n\r\n  count(): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & CollectionProperties & { count: number }\r\n    >\r\n  > {\r\n    return this._db.request({\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/count`,\r\n    });\r\n  }\r\n\r\n  async recalculateCount(): Promise<boolean> {\r\n    return this._db.request(\r\n      {\r\n        method: \"PUT\",\r\n        pathname: `/_api/collection/${encodeURIComponent(\r\n          this._name\r\n        )}/recalculateCount`,\r\n      },\r\n      (res) => res.parsedBody.result\r\n    );\r\n  }\r\n\r\n  figures(\r\n    details = false\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription &\r\n        CollectionProperties & { count: number; figures: Record<string, any> }\r\n    >\r\n  > {\r\n    return this._db.request({\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/figures`,\r\n      search: { details },\r\n    });\r\n  }\r\n\r\n  revision(): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & CollectionProperties & { revision: string }\r\n    >\r\n  > {\r\n    return this._db.request({\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/revision`,\r\n    });\r\n  }\r\n\r\n  checksum(\r\n    options?: CollectionChecksumOptions\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & { revision: string; checksum: string }\r\n    >\r\n  > {\r\n    return this._db.request({\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/checksum`,\r\n      search: options,\r\n    });\r\n  }\r\n\r\n  shards(\r\n    details?: boolean\r\n  ): Promise<\r\n    connection.ArangoApiResponse<\r\n      CollectionDescription & CollectionProperties & { shards: any }\r\n    >\r\n  > {\r\n    return this._db.request({\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}/shards`,\r\n      search: { details },\r\n    });\r\n  }\r\n\r\n  async rename(newName: string) {\r\n    const result = await this._db.renameCollection(this._name, newName);\r\n    this._name = newName;\r\n    return result;\r\n  }\r\n\r\n  truncate(\r\n    options?: TruncateCollectionOptions\r\n  ): Promise<connection.ArangoApiResponse<CollectionDescription>> {\r\n    return this._db.request({\r\n      method: \"PUT\",\r\n      pathname: `/_api/collection/${this._name}/truncate`,\r\n      search: options,\r\n    });\r\n  }\r\n\r\n  drop(options?: DropCollectionOptions) {\r\n    return this._db.request({\r\n      method: \"DELETE\",\r\n      pathname: `/_api/collection/${encodeURIComponent(this._name)}`,\r\n      search: options,\r\n    });\r\n  }\r\n\r\n  compact() {\r\n    return this._db.request({\r\n      method: \"PUT\",\r\n      pathname: `/_api/collection/${this._name}/compact`,\r\n    });\r\n  }\r\n  //#endregion\r\n\r\n  //#region Document operations\r\n  getResponsibleShard(\r\n    document: Partial<documents.Document<EntryResultType>>\r\n  ): Promise<string> {\r\n    return this._db.request(\r\n      {\r\n        method: \"PUT\",\r\n        pathname: `/_api/collection/${encodeURIComponent(\r\n          this._name\r\n        )}/responsibleShard`,\r\n        body: document,\r\n      },\r\n      (res) => res.parsedBody.shardId\r\n    );\r\n  }\r\n\r\n  documentId(selector: documents.DocumentSelector): string {\r\n    return documents._documentHandle(selector, this._name);\r\n  }\r\n\r\n  async documentExists(\r\n    selector: documents.DocumentSelector,\r\n    options: documents.DocumentExistsOptions = {}\r\n  ): Promise<boolean> {\r\n    const { ifMatch = undefined, ifNoneMatch = undefined } = options;\r\n    const headers = {} as Record<string, string>;\r\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\r\n    if (ifNoneMatch) headers[\"if-none-match\"] = ifNoneMatch;\r\n    try {\r\n      return await this._db.request(\r\n        {\r\n          method: \"HEAD\",\r\n          pathname: `/_api/document/${encodeURI(\r\n            documents._documentHandle(selector, this._name)\r\n          )}`,\r\n          headers,\r\n        },\r\n        (res) => {\r\n          if (ifNoneMatch && res.status === 304) {\r\n            throw new errors.HttpError(res);\r\n          }\r\n          return true;\r\n        }\r\n      );\r\n    } catch (err: any) {\r\n      if (err.code === 404) {\r\n        return false;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  documents(\r\n    selectors: (string | documents.ObjectWithDocumentKey)[],\r\n    options: documents.BulkReadDocumentsOptions = {}\r\n  ) {\r\n    const { allowDirtyRead = undefined } = options;\r\n    return this._db.request({\r\n      method: \"PUT\",\r\n      pathname: `/_api/document/${encodeURIComponent(this._name)}`,\r\n      search: { onlyget: true },\r\n      allowDirtyRead,\r\n      body: selectors,\r\n    });\r\n  }\r\n\r\n  async document(\r\n    selector: documents.DocumentSelector,\r\n    options: boolean | documents.ReadDocumentOptions = {}\r\n  ) {\r\n    if (typeof options === \"boolean\") {\r\n      options = { graceful: options };\r\n    }\r\n    const {\r\n      allowDirtyRead = undefined,\r\n      graceful = false,\r\n      ifMatch = undefined,\r\n      ifNoneMatch = undefined,\r\n    } = options;\r\n    const headers = {} as Record<string, string>;\r\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\r\n    if (ifNoneMatch) headers[\"if-none-match\"] = ifNoneMatch;\r\n    const result = this._db.request(\r\n      {\r\n        pathname: `/_api/document/${encodeURI(\r\n          documents._documentHandle(selector, this._name)\r\n        )}`,\r\n        headers,\r\n        allowDirtyRead,\r\n      },\r\n      (res) => {\r\n        if (ifNoneMatch && res.status === 304) {\r\n          throw new errors.HttpError(res);\r\n        }\r\n        return res.parsedBody;\r\n      }\r\n    );\r\n    if (!graceful) return result;\r\n    try {\r\n      return await result;\r\n    } catch (err: any) {\r\n      if (errors.isArangoError(err) && err.errorNum === DOCUMENT_NOT_FOUND) {\r\n        return null;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  save(\r\n    data: documents.DocumentData<EntryInputType>,\r\n    options?: documents.InsertDocumentOptions\r\n  ) {\r\n    return this._db.request(\r\n      {\r\n        method: \"POST\",\r\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\r\n        body: data,\r\n        search: options,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  saveAll(\r\n    data: Array<documents.DocumentData<EntryInputType>>,\r\n    options?: documents.InsertDocumentOptions\r\n  ) {\r\n    return this._db.request(\r\n      {\r\n        method: \"POST\",\r\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\r\n        body: data,\r\n        search: options,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  replace(\r\n    selector: documents.DocumentSelector,\r\n    newData: documents.DocumentData<EntryInputType>,\r\n    options: documents.ReplaceDocumentOptions = {}\r\n  ) {\r\n    const { ifMatch = undefined, ...opts } = options;\r\n    const headers = {} as Record<string, string>;\r\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\r\n    return this._db.request(\r\n      {\r\n        method: \"PUT\",\r\n        pathname: `/_api/document/${encodeURI(\r\n          documents._documentHandle(selector, this._name)\r\n        )}`,\r\n        headers,\r\n        body: newData,\r\n        search: opts,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  replaceAll(\r\n    newData: Array<\r\n      documents.DocumentData<EntryInputType> &\r\n        ({ _key: string } | { _id: string })\r\n    >,\r\n    options?: documents.ReplaceDocumentOptions\r\n  ) {\r\n    return this._db.request(\r\n      {\r\n        method: \"PUT\",\r\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\r\n        body: newData,\r\n        search: options,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  update(\r\n    selector: documents.DocumentSelector,\r\n    newData: documents.Patch<documents.DocumentData<EntryInputType>>,\r\n    options: documents.UpdateDocumentOptions = {}\r\n  ) {\r\n    const { ifMatch = undefined, ...opts } = options;\r\n    const headers = {} as Record<string, string>;\r\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\r\n    return this._db.request(\r\n      {\r\n        method: \"PATCH\",\r\n        pathname: `/_api/document/${encodeURI(\r\n          documents._documentHandle(selector, this._name)\r\n        )}`,\r\n        headers,\r\n        body: newData,\r\n        search: opts,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  updateAll(\r\n    newData: Array<\r\n      documents.Patch<documents.DocumentData<EntryInputType>> &\r\n        ({ _key: string } | { _id: string })\r\n    >,\r\n    options?: documents.UpdateDocumentOptions\r\n  ) {\r\n    return this._db.request(\r\n      {\r\n        method: \"PATCH\",\r\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\r\n        body: newData,\r\n        search: options,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  remove(\r\n    selector: documents.DocumentSelector,\r\n    options: documents.RemoveDocumentOptions = {}\r\n  ) {\r\n    const { ifMatch = undefined, ...opts } = options;\r\n    const headers = {} as Record<string, string>;\r\n    if (ifMatch) headers[\"if-match\"] = ifMatch;\r\n    return this._db.request(\r\n      {\r\n        method: \"DELETE\",\r\n        pathname: `/_api/document/${encodeURI(\r\n          documents._documentHandle(selector, this._name)\r\n        )}`,\r\n        headers,\r\n        search: opts,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  removeAll(\r\n    selectors: (string | documents.ObjectWithDocumentKey)[],\r\n    options?: documents.RemoveDocumentOptions\r\n  ) {\r\n    return this._db.request(\r\n      {\r\n        method: \"DELETE\",\r\n        pathname: `/_api/document/${encodeURIComponent(this._name)}`,\r\n        body: selectors,\r\n        search: options,\r\n      },\r\n      (res) => (options?.silent ? undefined : res.parsedBody)\r\n    );\r\n  }\r\n\r\n  import(\r\n    data: Buffer | Blob | string | any[],\r\n    options: documents.ImportDocumentsOptions & {\r\n      type?: \"\" | \"documents\" | \"list\" | \"auto\";\r\n    } = {}\r\n  ): Promise<documents.ImportDocumentsResult> {\r\n    const search = { ...options, collection: this._name };\r\n    if (Array.isArray(data)) {\r\n      search.type = Array.isArray(data[0]) ? \"\" : \"documents\";\r\n      const lines = data as any[];\r\n      data = lines.map((line) => JSON.stringify(line)).join(\"\\r\\n\") + \"\\r\\n\";\r\n    }\r\n    return this._db.request({\r\n      method: \"POST\",\r\n      pathname: \"/_api/import\",\r\n      body: data,\r\n      isBinary: true,\r\n      search,\r\n    });\r\n  }\r\n  //#endregion\r\n\r\n  //#region Edge operations\r\n  protected _edges(\r\n    selector: documents.DocumentSelector,\r\n    options: documents.DocumentEdgesOptions = {},\r\n    direction?: \"in\" | \"out\"\r\n  ) {\r\n    const { allowDirtyRead = undefined } = options;\r\n    return this._db.request({\r\n      pathname: `/_api/edges/${encodeURIComponent(this._name)}`,\r\n      allowDirtyRead,\r\n      search: {\r\n        direction,\r\n        vertex: documents._documentHandle(selector, this._name, false),\r\n      },\r\n    });\r\n  }\r\n\r\n  edges(\r\n    vertex: documents.DocumentSelector,\r\n    options?: documents.DocumentEdgesOptions\r\n  ) {\r\n    return this._edges(vertex, options);\r\n  }\r\n\r\n  inEdges(\r\n    vertex: documents.DocumentSelector,\r\n    options?: documents.DocumentEdgesOptions\r\n  ) {\r\n    return this._edges(vertex, options, \"in\");\r\n  }\r\n\r\n  outEdges(\r\n    vertex: documents.DocumentSelector,\r\n    options?: documents.DocumentEdgesOptions\r\n  ) {\r\n    return this._edges(vertex, options, \"out\");\r\n  }\r\n  //#endregion\r\n\r\n  //#region Index operations\r\n  async loadIndexes(): Promise<boolean> {\r\n    return this._db.request(\r\n      {\r\n        method: \"PUT\",\r\n        pathname: `/_api/collection/${encodeURIComponent(\r\n          this._name\r\n        )}/loadIndexesIntoMemory`,\r\n      },\r\n      (res) => res.parsedBody.result\r\n    );\r\n  }\r\n\r\n  indexes(options?: indexes.ListIndexesOptions) {\r\n    return this._db.request(\r\n      {\r\n        pathname: \"/_api/index\",\r\n        search: { collection: this._name, ...options },\r\n      },\r\n      (res) => res.parsedBody.indexes\r\n    );\r\n  }\r\n\r\n  index(selector: indexes.IndexSelector) {\r\n    return this._db.request({\r\n      pathname: `/_api/index/${encodeURI(indexes._indexHandle(selector, this._name))}`,\r\n    });\r\n  }\r\n\r\n  ensureIndex(options: indexes.EnsureIndexOptions) {\r\n    return this._db.request({\r\n      method: \"POST\",\r\n      pathname: \"/_api/index\",\r\n      body: options,\r\n      search: { collection: this._name },\r\n    });\r\n  }\r\n\r\n  dropIndex(selector: indexes.IndexSelector) {\r\n    return this._db.request({\r\n      method: \"DELETE\",\r\n      pathname: `/_api/index/${encodeURI(indexes._indexHandle(selector, this._name))}`,\r\n    });\r\n  }\r\n  //#endregion\r\n}\r\n//#endregion\r\n"]}