{"version":3,"file":"transactions.js","sourceRoot":"","sources":["../../src/transactions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * ```ts\r\n * import type { Transaction } from \"arangojs/transactions\";\r\n * ```\r\n *\r\n * The \"transactions\" module provides transaction related types and interfaces\r\n * for TypeScript.\r\n *\r\n * @packageDocumentation\r\n */\r\nimport * as collections from \"./collections.js\";\r\nimport * as connection from \"./connection.js\";\r\nimport * as databases from \"./databases.js\";\r\nimport * as errors from \"./errors.js\";\r\nimport { TRANSACTION_NOT_FOUND } from \"./lib/codes.js\";\r\n\r\n//#region Transaction operation options\r\n/**\r\n * Collections involved in a transaction.\r\n */\r\nexport type TransactionCollectionOptions = {\r\n  /**\r\n   * An array of collections or a single collection that will be read from or\r\n   * written to during the transaction with no other writes being able to run\r\n   * in parallel.\r\n   */\r\n  exclusive?:\r\n    | (string | collections.ArangoCollection)[]\r\n    | string\r\n    | collections.ArangoCollection;\r\n  /**\r\n   * An array of collections or a single collection that will be read from or\r\n   * written to during the transaction.\r\n   */\r\n  write?:\r\n    | (string | collections.ArangoCollection)[]\r\n    | string\r\n    | collections.ArangoCollection;\r\n  /**\r\n   * An array of collections or a single collection that will be read from\r\n   * during the transaction.\r\n   */\r\n  read?:\r\n    | (string | collections.ArangoCollection)[]\r\n    | string\r\n    | collections.ArangoCollection;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function coerceTransactionCollections(\r\n  options:\r\n    | (TransactionCollectionOptions & { allowImplicit?: boolean })\r\n    | (string | collections.ArangoCollection)[]\r\n    | string\r\n    | collections.ArangoCollection\r\n): CoercedTransactionCollections {\r\n  if (typeof options === \"string\") {\r\n    return { write: [options] };\r\n  }\r\n  if (Array.isArray(options)) {\r\n    return { write: options.map(collections.collectionToString) };\r\n  }\r\n  if (collections.isArangoCollection(options)) {\r\n    return { write: collections.collectionToString(options) };\r\n  }\r\n  const opts: CoercedTransactionCollections = {};\r\n  if (options) {\r\n    if (options.allowImplicit !== undefined) {\r\n      opts.allowImplicit = options.allowImplicit;\r\n    }\r\n    if (options.read) {\r\n      opts.read = Array.isArray(options.read)\r\n        ? options.read.map(collections.collectionToString)\r\n        : collections.collectionToString(options.read);\r\n    }\r\n    if (options.write) {\r\n      opts.write = Array.isArray(options.write)\r\n        ? options.write.map(collections.collectionToString)\r\n        : collections.collectionToString(options.write);\r\n    }\r\n    if (options.exclusive) {\r\n      opts.exclusive = Array.isArray(options.exclusive)\r\n        ? options.exclusive.map(collections.collectionToString)\r\n        : collections.collectionToString(options.exclusive);\r\n    }\r\n  }\r\n  return opts;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\ntype CoercedTransactionCollections = {\r\n  allowImplicit?: boolean;\r\n  exclusive?: string | string[];\r\n  write?: string | string[];\r\n  read?: string | string[];\r\n};\r\n\r\n/**\r\n * Options for how the transaction should be performed.\r\n */\r\nexport type TransactionOptions = {\r\n  /**\r\n   * Whether the transaction may read from collections not specified for this\r\n   * transaction. If set to `false`, accessing any collections not specified\r\n   * will result in the transaction being aborted to avoid potential deadlocks.\r\n   *\r\n   * Default: `true`.\r\n   */\r\n  allowImplicit?: boolean;\r\n  /**\r\n   * If set to `true`, the request will explicitly permit ArangoDB to return a\r\n   * potentially dirty or stale result and arangojs will load balance the\r\n   * request without distinguishing between leaders and followers.\r\n   */\r\n  allowDirtyRead?: boolean;\r\n  /**\r\n   * Determines whether to force the transaction to write all data to disk\r\n   * before returning.\r\n   */\r\n  waitForSync?: boolean;\r\n  /**\r\n   * Determines how long the database will wait while attempting to gain locks\r\n   * on collections used by the transaction before timing out.\r\n   */\r\n  lockTimeout?: number;\r\n  /**\r\n   * Determines the transaction size limit in bytes.\r\n   */\r\n  maxTransactionSize?: number;\r\n  /**\r\n   * If set to `true`, the fast lock round will be skipped, which makes each\r\n   * locking operation take longer but guarantees deterministic locking order\r\n   * and may avoid deadlocks when many concurrent transactions are queued and\r\n   * try to access the same collection with an exclusive lock.\r\n   */\r\n  skipFastLockRound?: boolean;\r\n};\r\n\r\n/**\r\n * Options for how the transaction should be committed.\r\n */\r\nexport type TransactionCommitOptions = {\r\n  /**\r\n   * If set to `true`, the request will explicitly permit ArangoDB to return a\r\n   * potentially dirty or stale result and arangojs will load balance the\r\n   * request without distinguishing between leaders and followers.\r\n   */\r\n  allowDirtyRead?: boolean;\r\n};\r\n\r\n/**\r\n * Options for how the transaction should be aborted.\r\n */\r\nexport type TransactionAbortOptions = {\r\n  /**\r\n   * If set to `true`, the request will explicitly permit ArangoDB to return a\r\n   * potentially dirty or stale result and arangojs will load balance the\r\n   * request without distinguishing between leaders and followers.\r\n   */\r\n  allowDirtyRead?: boolean;\r\n};\r\n//#endregion\r\n\r\n//#region Transaction operation results\r\n/**\r\n * Description of a transaction in a list of transactions.\r\n *\r\n * See also {@link TransactionInfo}.\r\n */\r\nexport type TransactionDescription = {\r\n  /**\r\n   * Unique identifier of the transaction.\r\n   */\r\n  id: string;\r\n  /**\r\n   * Status (or \"state\") of the transaction.\r\n   */\r\n  state: \"running\" | \"committed\" | \"aborted\";\r\n};\r\n\r\n/**\r\n * Status of a given transaction.\r\n *\r\n * See also {@link TransactionDescription}.\r\n */\r\nexport type TransactionInfo = {\r\n  /**\r\n   * Unique identifier of the transaction.\r\n   */\r\n  id: string;\r\n  /**\r\n   * Status of the transaction.\r\n   */\r\n  status: \"running\" | \"committed\" | \"aborted\";\r\n};\r\n//#endregion\r\n//#region Transaction class\r\n/**\r\n * Indicates whether the given value represents a {@link Transaction}.\r\n *\r\n * @param transaction - A value that might be a transaction.\r\n */\r\nexport function isArangoTransaction(\r\n  transaction: any\r\n): transaction is Transaction {\r\n  return Boolean(transaction && transaction.isArangoTransaction);\r\n}\r\n\r\n/**\r\n * Represents a streaming transaction in a {@link databases.Database}.\r\n */\r\nexport class Transaction {\r\n  protected _db: databases.Database;\r\n  protected _id: string;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor(db: databases.Database, id: string) {\r\n    this._db = db;\r\n    this._id = id;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   *\r\n   * Indicates that this object represents an ArangoDB transaction.\r\n   */\r\n  get isArangoTransaction(): true {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Database this transaction belongs to.\r\n   */\r\n  get database() {\r\n    return this._db;\r\n  }\r\n\r\n  /**\r\n   * Unique identifier of this transaction.\r\n   *\r\n   * See {@link databases.Database#transaction}.\r\n   */\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Checks whether the transaction exists.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const trx = db.transaction(\"some-transaction\");\r\n   * const result = await trx.exists();\r\n   * // result indicates whether the transaction exists\r\n   * ```\r\n   */\r\n  async exists(): Promise<boolean> {\r\n    try {\r\n      await this.get();\r\n      return true;\r\n    } catch (err: any) {\r\n      if (errors.isArangoError(err) && err.errorNum === TRANSACTION_NOT_FOUND) {\r\n        return false;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves general information about the transaction.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const col = db.collection(\"some-collection\");\r\n   * const trx = db.beginTransaction(col);\r\n   * await trx.step(() => col.save({ hello: \"world\" }));\r\n   * const info = await trx.get();\r\n   * // the transaction exists\r\n   * ```\r\n   */\r\n  get(): Promise<TransactionInfo> {\r\n    return this._db.request(\r\n      {\r\n        pathname: `/_api/transaction/${encodeURIComponent(this.id)}`,\r\n      },\r\n      (res) => res.parsedBody.result\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Attempts to commit the transaction to the databases.\r\n   *\r\n   * @param options - Options for comitting the transaction.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const col = db.collection(\"some-collection\");\r\n   * const trx = db.beginTransaction(col);\r\n   * await trx.step(() => col.save({ hello: \"world\" }));\r\n   * const result = await trx.commit();\r\n   * // result indicates the updated transaction status\r\n   * ```\r\n   */\r\n  commit(options: TransactionCommitOptions = {}): Promise<TransactionInfo> {\r\n    const { allowDirtyRead = undefined } = options;\r\n    return this._db.request(\r\n      {\r\n        method: \"PUT\",\r\n        pathname: `/_api/transaction/${encodeURIComponent(this.id)}`,\r\n        allowDirtyRead,\r\n      },\r\n      (res) => res.parsedBody.result\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Attempts to abort the transaction to the databases.\r\n   *\r\n   * @param options - Options for aborting the transaction.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const col = db.collection(\"some-collection\");\r\n   * const trx = db.beginTransaction(col);\r\n   * await trx.step(() => col.save({ hello: \"world\" }));\r\n   * const result = await trx.abort();\r\n   * // result indicates the updated transaction status\r\n   * ```\r\n   */\r\n  abort(options: TransactionAbortOptions = {}): Promise<TransactionInfo> {\r\n    const { allowDirtyRead = undefined } = options;\r\n    return this._db.request(\r\n      {\r\n        method: \"DELETE\",\r\n        pathname: `/_api/transaction/${encodeURIComponent(this.id)}`,\r\n        allowDirtyRead,\r\n      },\r\n      (res) => res.parsedBody.result\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Executes the given function locally as a single step of the transaction.\r\n   *\r\n   * @param T - Type of the callback's returned promise.\r\n   * @param callback - Callback function returning a promise.\r\n   *\r\n   * **Warning**: The callback function should wrap a single call of an async\r\n   * arangojs method (e.g. a method on a `Collection` object of a collection\r\n   * that is involved in the transaction or the `db.query` method).\r\n   * If the callback function is async, only the first promise-returning (or\r\n   * async) method call will be executed as part of the transaction. See the\r\n   * examples below for how to avoid common mistakes when using this method.\r\n   *\r\n   * **Note**: Avoid defining the callback as an async function if possible\r\n   * as arangojs will throw an error if the callback did not return a promise.\r\n   * Async functions will return an empty promise by default, making it harder\r\n   * to notice if you forgot to return something from the callback.\r\n   *\r\n   * **Note**: Although almost anything can be wrapped in a callback and passed\r\n   * to this method, that does not guarantee ArangoDB can actually do it in a\r\n   * transaction. Refer to the ArangoDB documentation if you are unsure whether\r\n   * a given operation can be executed as part of a transaction. Generally any\r\n   * modification or retrieval of data is eligible but modifications of\r\n   * collections or databases are not.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const db = new Database();\r\n   * const vertices = db.collection(\"vertices\");\r\n   * const edges = db.collection(\"edges\");\r\n   * const trx = await db.beginTransaction({ write: [vertices, edges] });\r\n   *\r\n   * // The following code will be part of the transaction\r\n   * const left = await trx.step(() => vertices.save({ label: \"left\" }));\r\n   * const right = await trx.step(() => vertices.save({ label: \"right\" }));\r\n   *\r\n   * // Results from preceding actions can be used normally\r\n   * await trx.step(() => edges.save({\r\n   *   _from: left._id,\r\n   *   _to: right._id,\r\n   *   data: \"potato\"\r\n   * }));\r\n   *\r\n   * // Transaction must be committed for changes to take effected\r\n   * // Always call either trx.commit or trx.abort to end a transaction\r\n   * await trx.commit();\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // BAD! If the callback is an async function it must only use await once!\r\n   * await trx.step(async () => {\r\n   *   await collection.save(data);\r\n   *   await collection.save(moreData); // WRONG\r\n   * });\r\n   *\r\n   * // BAD! Callback function must use only one arangojs call!\r\n   * await trx.step(() => {\r\n   *  return collection.save(data)\r\n   *    .then(() => collection.save(moreData)); // WRONG\r\n   * });\r\n   *\r\n   * // BETTER: Wrap every arangojs method call that should be part of the\r\n   * // transaction in a separate `trx.step` call\r\n   * await trx.step(() => collection.save(data));\r\n   * await trx.step(() => collection.save(moreData));\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // BAD! If the callback is an async function it must not await before\r\n   * // calling an arangojs method!\r\n   * await trx.step(async () => {\r\n   *   await doSomethingElse();\r\n   *   return collection.save(data); // WRONG\r\n   * });\r\n   *\r\n   * // BAD! Any arangojs inside the callback must not happen inside a promise\r\n   * // method!\r\n   * await trx.step(() => {\r\n   *   return doSomethingElse()\r\n   *     .then(() => collection.save(data)); // WRONG\r\n   * });\r\n   *\r\n   * // BETTER: Perform any async logic needed outside the `trx.step` call\r\n   * await doSomethingElse();\r\n   * await trx.step(() => collection.save(data));\r\n   *\r\n   * // OKAY: You can perform async logic in the callback after the arangojs\r\n   * // method call as long as it does not involve additional arangojs method\r\n   * // calls, but this makes it easy to make mistakes later\r\n   * await trx.step(async () => {\r\n   *   await collection.save(data);\r\n   *   await doSomethingDifferent(); // no arangojs method calls allowed\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // BAD! The callback should not use any functions that themselves use any\r\n   * // arangojs methods!\r\n   * async function saveSomeData() {\r\n   *   await collection.save(data);\r\n   *   await collection.save(moreData);\r\n   * }\r\n   * await trx.step(() => saveSomeData()); // WRONG\r\n   *\r\n   * // BETTER: Pass the transaction to functions that need to call arangojs\r\n   * // methods inside a transaction\r\n   * async function saveSomeData(trx) {\r\n   *   await trx.step(() => collection.save(data));\r\n   *   await trx.step(() => collection.save(moreData));\r\n   * }\r\n   * await saveSomeData(); // no `trx.step` call needed\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // BAD! You must wait for the promise to resolve (or await on the\r\n   * // `trx.step` call) before calling `trx.step` again!\r\n   * trx.step(() => collection.save(data)); // WRONG\r\n   * await trx.step(() => collection.save(moreData));\r\n   *\r\n   * // BAD! The trx.step callback can not make multiple calls to async arangojs\r\n   * // methods, not even using Promise.all!\r\n   * await trx.step(() => Promise.all([ // WRONG\r\n   *   collection.save(data),\r\n   *   collection.save(moreData),\r\n   * ]));\r\n   *\r\n   * // BAD! Multiple `trx.step` calls can not run in parallel!\r\n   * await Promise.all([ // WRONG\r\n   *   trx.step(() => collection.save(data)),\r\n   *   trx.step(() => collection.save(moreData)),\r\n   * ]));\r\n   *\r\n   * // BETTER: Always call `trx.step` sequentially, one after the other\r\n   * await trx.step(() => collection.save(data));\r\n   * await trx.step(() => collection.save(moreData));\r\n   *\r\n   * // OKAY: The then callback can be used if async/await is not available\r\n   * trx.step(() => collection.save(data))\r\n   *   .then(() => trx.step(() => collection.save(moreData)));\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // BAD! The callback will return an empty promise that resolves before\r\n   * // the inner arangojs method call has even talked to ArangoDB!\r\n   * await trx.step(async () => {\r\n   *   collection.save(data); // WRONG\r\n   * });\r\n   *\r\n   * // BETTER: Use an arrow function so you don't forget to return\r\n   * await trx.step(() => collection.save(data));\r\n   *\r\n   * // OKAY: Remember to always return when using a function body\r\n   * await trx.step(() => {\r\n   *   return collection.save(data); // easy to forget!\r\n   * });\r\n   *\r\n   * // OKAY: You do not have to use arrow functions but it helps\r\n   * await trx.step(function () {\r\n   *   return collection.save(data);\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // BAD! You can not pass promises instead of a callback!\r\n   * await trx.step(collection.save(data)); // WRONG\r\n   *\r\n   * // BETTER: Wrap the code in a function and pass the function instead\r\n   * await trx.step(() => collection.save(data));\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // WORSE: Calls to non-async arangojs methods don't need to be performed\r\n   * // as part of a transaction\r\n   * const collection = await trx.step(() => db.collection(\"my-documents\"));\r\n   *\r\n   * // BETTER: If an arangojs method is not async and doesn't return promises,\r\n   * // call it without `trx.step`\r\n   * const collection = db.collection(\"my-documents\");\r\n   * ```\r\n   */\r\n  step<T>(callback: () => Promise<T>): Promise<T> {\r\n    const conn = (this._db as any)._connection as connection.Connection;\r\n    conn.setTransactionId(this.id);\r\n    try {\r\n      const promise = callback();\r\n      if (!promise) {\r\n        throw new Error(\r\n          \"Transaction callback was not an async function or did not return a promise!\"\r\n        );\r\n      }\r\n      return Promise.resolve(promise);\r\n    } finally {\r\n      conn.clearTransactionId();\r\n    }\r\n  }\r\n}\r\n//#endregion\r\n"]}